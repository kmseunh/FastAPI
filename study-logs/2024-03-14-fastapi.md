# 본문 - 다중 매개변수, 필드, 중첩 모델

_2024.03.14_

#### 1. 다중 매개변수

1. `Path`, `Query` 및 본문 매개변수 혼합
`Path`, `Query` 및 요청 본문 매개변수 선언을 자유롭게 혼합해서 사용할 수 있다.

```py
from typing import Union

from fastapi import FastAPI, Path
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


@app.put("/items/{item_id}")
async def update_item(
    *, # 모든 매개변수는 키워드 인자로만 지정
    item_id: int = Path(title="The ID of the item to get", ge=0, le=1000),
    q: Union[str, None] = None, # 문자열 또는 None이 될 수 있는 쿼리 매개변수
    item: Union[Item, None] = None, # Item 객체 또는 None이 될 수 있는 바디 매개변수
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    if item:
        results.update({"item": item})
    return results

# 기본 값을 None으로 설정해 본문 매개변수를 선택사항으로 선언할 수 있다.
#  본문으로 부터 가져온 item은 기본값이 None이기 때문에 선택사항
```

2. 다중 본문 매개변수
위 예제에서 보았듯이, 경로 작동은 `Item` 속성을 가진 JSON 본문을 예상하지만 다중 본문 매개변수 역시 선언할 수 있다.

```py
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


# 아이템을 나타내는 Pydantic 모델인 Item
class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


# 사용자를 나타내는 Pydantic 모델인 User
class User(BaseModel):
    username: str
    full_name: Union[str, None] = None


# 정수형 item_id 경로 매개변수와 Item 및 User 모델로 정의된 본문 매개변수를 받는다.
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, user: User):
    results = {"item_id": item_id, "item": item, "user": user}
    return results


## 본문 내의 단일 값
# importance라는 키 추가
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, user: User, importance: int = Body()): 
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    return results

# 단일 값을 그대로 선언한다면, FastAPI는 쿼리 매개변수로 가정하지만,
# Body를 사용해 다른 본문 키로 처리하도록 제어


## 다중 본문 매개변수와 쿼리
# 기본적으로 단일 값은 쿼리 매개변수로 해석되므로, 명시적으로 Query를 추가할 필요가 없다.
@app.put("/items/{item_id}")
async def update_item(
    *,
    item_id: int,
    item: Item,
    user: User,
    importance: int = Body(gt=0), # 선택적인 요청 본문이 추가 (기본값은 0)
    q: Union[str, None] = None,
):
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    if q:
        results.update({"q": q})
    return results
```

#### 2. 필드

`Pydantic`의 `Field`를 사용하여 모델 내에서 검증과 메타데이터를 선언할 수 있다.

- **선택적 필드:** 필드를 정의할 때 `default` 매개변수를 사용하여 기본값을 설정하거나, 필드의 유형을 `Optional` 또는 `Union[type, None]`으로 지정

- **필수 필드:** 필드를 정의할 때 `default` 매개변수를 설정하지 않고, 필드의 유형만 명시

1. `Model Attribute` 선언

```py
from typing import Annotated

from fastapi import Body, FastAPI
from pydantic import BaseModel, Field

app = FastAPI()


# 아이템을 나타내는 Pydantic 모델인 Item
class Item(BaseModel):
    name: str   # 아이템 이름 (필수 필드)
    description: str | None = Field(    # 아이템 설명 (선택적 필드)
        default=None, title="The description of the item", max_length=300
    )
    price: float = Field(gt=0, description="The price must be greater than zero")   # 아이템 가격 (필수 필드)
    tax: float | None = None


# Annotated를 사용하면 타입 힌트에 여러 개의 어노테이션(Annotation)을 추가할 수 있다. 
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):
    results = {"item_id": item_id, "item": item}
    return results

# Field는 Query, Path와 Body와 같은 방식으로 동작하며, 모두 같은 매개변수들 등을 가진다.
```

#### 중첩 모델

`FastAPI`를 이용하면 (`Pydantic` 덕분에) 단독으로 깊이 중첩된 모델을 정의, 검증, 문서화하며 사용할 수 있다.

1. `List` 필드
`Attribute`를 서브타입으로 정의할 수 있다.

```py
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list = [] # 아이템의 태그 목록을 나타내는 선택적 필드 (기본값은 빈 리스트)


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results


## 타입 매개변수가 있는 List 필드
from typing import List, Union  # typing 모듈에서 List 임포트

tags: List[str] = [] # 대괄호를 사용하여 "타입 매개변수"로 내부 타입 전달


## 집합 타입
from typing import Set, Union   # typing 모듈에서 Set 임포트

tags: Set[str] = set()  # tags를 str의 set으로 선언
```

2. 중첩 모델
특정한 `Attribute`의 이름, 타입, 검증을 사용하여 깊게 중첩된 `JSON` "객체"를 선언할 수 있다.

```py
from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


# 이미지를 나타내는 Pydantic 모델인 Image
class Image(BaseModel):
    url: str
    name: str


# 아이템을 나타내는 Pydantic 모델인 Item
class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    image: Union[Image, None] = None # Attribute의 타입으로 사용


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results


## 서브모델 리스트를 갖는 Attribute
class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    # list, set 등의 서브타입으로 Pydantic 모델을 사용할 수도 있다.
    images: Union[List[Image], None] = None
```

3. 깊게 중첩된 모델
단독으로 깊게 중첩된 모델을 정의할 수 있다.

```py
from typing import List, Set, Union

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl    # 이미지 URL은 HTTP URL이어야 함
    name: str


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()
    images: Union[List[Image], None] = None # 아이템 이미지 목록 (선택적 필드)


class Offer(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    items: List[Item]   # 제안에 포함된 아이템 목록 (필수 필드)


@app.post("/offers/")
async def create_offer(offer: Offer):
    return offer

# Offer 모델은 여러 개의 Item을 포함하고 있으며, 각각의 Item은 여러 개의 이미지를 가질 수 있다. 
```

<br>

> 예상되는 JSON 본문의 최상위 값이 JSON `array`(파이썬 `list`)면, Pydantic 모델에서와 마찬가지로 함수의 매개변수에서 타입을 선언할 수 있다.
>
> ```py
> async def create_multiple_images(images: List[Image]):
> ```
