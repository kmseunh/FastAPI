# FastAPI - Instagram Backend

_2024.04.06_

#### 1. 게시물 CRUD를 위한 Post Model 및 Hashtag Model 생성

`model.py` 생성

- Post Model

```py
# post/models.py
class Post(Base):
    """게시물(Post) 모델"""

    __tablename__ = "posts"

    # 게시물 ID
    id = Column(Integer, primary_key=True, index=True)
    # 게시물 내용
    content = Column(String)
    # 게시물 이미지 경로
    image = Column(String)
    # 게시물 위치
    location = Column(String)
    # 게시물 작성 일시
    created_dt = Column(DateTime, default=datetime.now)
    # 게시물 좋아요 수
    likes_count = Column(Integer, default=0)

    # 게시물 작성자와의 관계 설정
    author_id = Column(Integer, ForeignKey("users.id"))
    author = relationship("User", back_populates="posts")

    # 게시물과 해시태그의 다대다 관계 설정
    hashtags = relationship("Hashtag", secondary=post_hashtags, back_populates="posts")
    # 게시물에 좋아요를 누른 사용자들과의 관계 설정
    like_by_users = relationship(
        "User", secondary=post_likes, back_populates="liked_posts"
    )
```

- Hashtag Model

```py
# post/models.py
class Hashtag(Base):
    """해시태그(Hashtag) 모델"""

    __tablename__ = "hashtags"

    # 해시태그 ID
    id = Column(Integer, primary_key=True, index=True)
    # 해시태그 이름
    name = Column(String, index=True)

    # 해당 해시태그를 사용한 게시물들과의 관계 설정
    posts = relationship("Post", secondary=post_hashtags, back_populates="hashtags")
```

Model 간의 관계 정의

```py
# post/models.py
# 게시물과 해시태그의 다대다 관계를 나타내는 연결 테이블
post_hashtags = Table(
    "post_hashtags",
    Base.metadata,
    Column("post_id", Integer, ForeignKey("posts.id")),
    Column("hashtag_id", Integer, ForeignKey("hashtags.id")),
)

# 게시물에 대한 좋아요를 나타내는 연결 테이블
post_likes = Table(
    "post_likes",
    Base.metadata,
    Column("user_id", Integer, ForeignKey("users.id")),
    Column("post_id", Integer, ForeignKey("posts.id")),
)
```

`schema.py` 생성

```py
# post/schemas.py
class Hashtag(BaseModel):
    id: int
    name: str


class PostCreate(BaseModel):
    content: Optional[str] = None
    image: str
    location: Optional[str] = None


class Post(PostCreate):
    id: int
    author_id: int
    likes_count: int
    created_dt: datetime
    hashtags: List[Hashtag] = []

    class Config:
        orm_mode = True
```

#### 2. 게시물 생성 함수 및 라우터 생성

게시물 생성을 위한 함수

```py
# post/service.py
async def create_post_svc(
    post: PostCreate, user_id: int, db: Session = Depends(get_db)
):
    """게시물을 생성하고 해당 게시물에 대한 해시태그를 생성하는 서비스 함수"""
    db_post = Post(
        content=post.content,
        image=post.image,
        location=post.location,
        author_id=user_id,
    )

    # 게시물에 대한 해시태그 생성 함수 호출
    await create_hashtags_svc(db_post, db)

    db.add(db_post)
    db.commit()
    db.refresh(db_post)

    return db_post
```

게시물 생성 라우터

```py
@router.post("/", response_model=Post, status_code=status.HTTP_201_CREATED)
async def create_post(post: PostCreate, token: str, db: Session = Depends(get_db)):
    """
    새로운 게시물을 생성합니다.

    Parameters:
    - post: 생성할 게시물의 내용과 이미지를 담은 객체
    - token: 사용자 인증 토큰
    - db: 데이터베이스 세션 객체

    Returns:
    - 생성된 게시물의 정보

    Raises:
    - HTTPException: 사용자 인증 실패 시 401 에러 반환
    """
    # 현재 사용자 가져오기
    user = await get_current_user(token, db)

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="you are not authorized"
        )

    # 게시물 생성 서비스 함수 호출
    db_post = await create_post_svc(post, user.id, db)
    return db_post
```

#### 3. 현재 사용자의 게시물 목록 조회 함수 및 라우터 생성

현재 사용자의 게시물 목록 조회 함수

```py
async def get_users_posts_svc(
    user_id: int, db: Session = Depends(get_db)
) -> List[PostSchema]:
    """특정 사용자의 게시물 목록을 가져오는 서비스 함수"""
    posts = (
        db.query(Post)
        .filter(Post.author_id == user_id)
        .order_by(desc(Post.created_dt))
        .all()
    )

    return posts
```

현재 사용자의 게시물 목록 조회 라우터

```py
@router.get("/user", response_model=list[Post])
async def get_current_user_posts(token: str, db: Session = Depends(get_db)):
    """
    현재 사용자의 게시물 목록을 가져옵니다.

    Parameters:
    - token: 사용자 인증 토큰
    - db: 데이터베이스 세션 객체

    Returns:
    - 현재 사용자의 게시물 목록
    """
    # 현재 사용자 가져오기
    user = await get_current_user(token, db)

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="you are not authorized"
        )

    # 현재 사용자의 게시물 목록 가져오기 서비스 함수 호출
    posts = await get_users_posts_svc(user.id, db)
    return posts
```

#### 4. 특정 사용자의 게시물 목록 조회 함수 및 라우터 생성

특정 사용자의 게시물 목록 조회 함수

```py
async def get_posts_by_username(
    username: str, db: Session = Depends(get_db)
) -> List[Post]:
    """
    특정 사용자가 작성한 게시물 목록을 가져오는 함수입니다.

    Parameters:
    - username: 게시물을 작성한 사용자의 이름
    - db: 데이터베이스 세션 객체

    Returns:
    - 특정 사용자가 작성한 게시물 목록

    Notes:
    - 사용자 이름에 해당하는 게시물을 데이터베이스에서 찾아 반환합니다.
    """
    return db.query(Post).filter(Post.author.has(username=username)).all()
```

특정 사용자의 게시물 목록 조회 라우터

```py
@router.get("/user/{username}", response_model=list[Post])
async def get_user_posts(username: str, db: Session = Depends(get_db)):
    """
    특정 사용자의 게시물 목록을 가져오는 엔드포인트입니다.

    Parameters:
    - username: 게시물을 작성한 사용자의 이름
    - db: 데이터베이스 세션 객체

    Returns:
    - 특정 사용자의 게시물 목록

    Notes:
    - 해당 사용자가 존재하는 경우 해당 사용자가 작성한 게시물 목록을 반환합니다.
    - 사용자가 존재하지 않는 경우 빈 목록을 반환합니다.
    """
    # 사용자 이름을 통해 해당 사용자가 존재하는지 확인합니다.
    user_exists = await existing_user(username, "", db)
    if user_exists:
        # 사용자가 존재하면 해당 사용자가 작성한 게시물 목록을 반환합니다.
        user_posts = await get_posts_by_username(username, db)
        return user_posts
    else:
        # 사용자가 존재하지 않는 경우 빈 목록을 반환합니다.
        return []
```
