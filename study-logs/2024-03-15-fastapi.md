# 쿠키 & 헤더 매개변수, 응답 모델

_2024.03.15_

#### 1. 쿠키 매개변수

쿠키 매개변수를 `Query`와 `Path` 매개변수들과 같은 방식으로 정의할 수 있다.

```py
# Cookie 매개변수 선언
from typing import Annotated

from fastapi import Cookie, FastAPI

app = FastAPI()


# 쿠키(Cookie)에서 ads_id 값을 가져와서 반환하는 엔드포인트
@app.get("/items/")
async def read_items(ads_id: Annotated[str | None, Cookie()] = None):
    return {"ads_id": ads_id}

# Cookie()를 사용하여 ads_id 매개변수를 쿠키에서 가져온 값으로 초기화 
# 이를 통해 FastAPI는 요청의 쿠키에서 ads_id 값을 가져와서 해당 매개변수에 전달
```

#### 2. 헤더 매개변수

헤더 매개변수를 `Query`, `Path` 그리고 `Cookie` 매개변수들과 같은 방식으로 정의할 수 있다.

```py
# Header 매개변수 선언
from typing import Union

from fastapi import FastAPI, Header

app = FastAPI()


# "User-Agent" 헤더를 사용하여 클라이언트의 정보를 가져오는 엔드포인트
@app.get("/items/")
async def read_items(user_agent: Union[str, None] = Header(default=None)):
    return {"User-Agent": user_agent}

# Header(default=None)을 사용하여 user_agent 매개변수를 요청의 User-Agent 헤더 값으로 초기화
# 이를 통해 FastAPI는 요청의 헤더에서 User-Agent 값을 가져와서 해당 매개변수에 전달
# 만약 요청에 User-Agent 헤더가 없을 경우 기본값은 None
```

1. 자동변환
대부분의 표준 헤더는 "마이너스 기호" (`-`)라고도 하는 "하이픈" 문자로 구분되지만, 파이썬에서 `user-agent`와 같은 형태의 변수는 유효하지 않다.
따라서 `Header`는 기본적으로 매개변수 이름을 언더스코어(`_`)에서 하이픈(`-`)으로 변환하여 헤더를 추출하고 기록한다.

```py
from typing import Union

from fastapi import FastAPI, Header

app = FastAPI()


# 특이한 헤더 값을 가져오는 엔드포인트
@app.get("/items/")
async def read_items(
    strange_header: Union[str, None] = Header(default=None, convert_underscores=False)
):
    return {"strange_header": strange_header}

# Header(default=None, convert_underscores=False)를 사용하여 strange_header 매개변수를 요청의 헤더 값으로 초기화
# 이 때 convert_underscores 매개변수를 False로 설정하여 FastAPI에게 헤더 이름을 변환하지 않도록 지시
```

2. 중복 헤더
중복 헤더들 즉, 다중값을 갖는 동일한 헤더를 수신할 수 있다.
중복 헤더의 모든 값을 파이썬 `list`로 수신한다.

```py
from typing import List, Union

from fastapi import FastAPI, Header

app = FastAPI()


# "X-Token" 헤더에서 여러 값을 가져오는 엔드포인트
@app.get("/items/")
async def read_items(x_token: Union[List[str], None] = Header(default=None)):
    return {"X-Token values": x_token}

# Header(default=None)를 사용하여 x_token 매개변수를 요청의 X-Token 헤더 값으로 초기화 
# 이를 통해 FastAPI는 요청의 헤더에서 X-Token 값을 가져와서 해당 매개변수에 전달
# 만약 요청에 X-Token 헤더가 없을 경우 기본값은 None
```

#### 3. 응답 모델

어떤 경로 작동이든 매개변수 `response_model`를 사용하여 응답을 위한 모델을 선언할 수 있다.
(`@app.get()`, `@app.post()`, `@app.put()`, `@app.delete()`)

```py
from typing import Any, List, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: List[str] = []


# POST 요청을 통해 새로운 아이템을 생성하는 엔드포인트
@app.post("/items/", response_model=Item)
async def create_item(item: Item) -> Any:
    return item


# GET 요청을 통해 모든 아이템을 읽어오는 엔드포인트입니다.
@app.get("/items/", response_model=List[Item])
async def read_items() -> Any:
    return [
        {"name": "Portal Gun", "price": 42.0},
        {"name": "Plumbus", "price": 32.0},
    ]

# response_model를 사용하여:
# 출력 데이터를 타입 선언으로 변환.
# 데이터 검증.
# OpenAPI 경로 작동의 응답에 JSON 스키마 추가.
# 자동 생성 문서 시스템에 사용.
# 해당 모델의 출력 데이터 제한. (제일 중요)
```

1. 출력 모델 추가
평문 비밀번호로 입력 모델을 만들고 해당 비밀번호 없이 출력 모델을 만들 수 있다.

```py
from typing import Any, Union

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()

# 사용자 정보를 입력받는 UserIn 모델
# 여기서 경로 작동 함수가 비밀번호를 포함하는 동일한 입력 사용자를 반환할지라도
class UserIn(BaseModel):
    username: str  # 사용자명
    password: str  # 비밀번호
    email: EmailStr  # 이메일
    full_name: Union[str, None] = None 


# 사용자 정보를 반환하는 UserOut 모델
class UserOut(BaseModel):
    username: str  # 사용자명
    email: EmailStr  # 이메일
    full_name: Union[str, None] = None


# 새로운 사용자를 생성하는 엔드포인트.
# response_model을 UserOut 모델로 선언했기 때문에 비밀번호를 포함하지 않는다.
@app.post("/user/", response_model=UserOut)
async def create_user(user: UserIn) -> Any:
    return user
```

2. 응답 모델 인코딩 매개변수
모델이 기본값을 가지고 있을 때, 실제로 저장되지 않았을 경우 결과에서 값을 생략하고 싶을 수 있다.

```py
from typing import List, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: float = 10.5
    tags: List[str] = []


# 예시 아이템 데이터를 담은 딕셔너리
items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


# # 특정 아이템을 조회하는 엔드포인트
@app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
async def read_item(item_id: str):
    return items[item_id]

# response_model=Item: 이 엔드포인트의 응답은 Item 모델에 맞춰 반환된다.
# response_model_exclude_unset=True: 응답에서 값이 지정되지 않은(Unset) 필드를 제외한다.


## response_model_include 및 response_model_exclude
# 이들은 포함(나머지 생략)하거나 제외(나머지 포함) 할 어트리뷰트의 이름과 str의 set을 받는다.

# 특정 아이템의 이름과 설명을 조회하는 엔드포인트
@app.get(
    "/items/{item_id}/name",
    response_model=Item,
    response_model_include={"name", "description"},
)
async def read_item_name(item_id: str):
    return items[item_id]


# 특정 아이템의 공개 데이터를 조회하는 엔드포인트 (세금 정보 제외)
@app.get("/items/{item_id}/public", response_model=Item, response_model_exclude={"tax"})
async def read_item_public_data(item_id: str):
    return items[item_id]
```
